##目标：
- 提供堆栈对比功能，实现今日产生的堆栈文件与昨日新出现的堆栈信息的自动对比，直观显示今日新出现的bug的堆栈信息；
- 提供黑名单增删操作，过滤堆栈文件中的无效信息。

##解决问题：
用堆栈的自动对比替代人工对比，实现堆栈对比自动化，减轻测试方压力，提高堆栈对比准确率。

##解决方案：
- 利用gin框架搭建服务器，对比功能上，提供两种对比模式：personalRun&dailyRun；黑名单维护功能上，提供add,delete,list三个接口
  personalRun:指个人行为的对比，只使用黑名单过滤方法，将堆栈信息中存在的黑名单信息进行过滤。
  dailyRun:指测试方设置的定时对比行为，每天一次，先使用黑名单进行过滤，再与前一天的堆栈文件进行对比，过滤掉前一天出现过的堆栈信息。
- 根据task_id获取task具体信息，其中包括堆栈信息的url。再进行GET请求，使用正则匹配的方式获取到存有堆栈信息的堆栈文件。再根据正则匹配提取出堆栈信息并存储在map中。
- 进而根据用户所选择的对比模式进行对比，其中黑名单在服务启动时自动从tos服务中获取，并常驻于服务中。对于黑名单的维护，使用到读写锁，可以同读，但不能同时读写。每次写入之后都会重新上传至tos服务中。

##解决方案2.0
- 由于需求的变化，解决方案相对应做出了调整，需求的变化主要在于，之前的对比以堆栈信息为单位，而现在的对比单位改为堆栈块。每一个堆栈块拆解之后，提取某些特定部分并进行哈希，作为该堆栈块的ID。
  之后的过滤无论是黑名单过滤还是堆栈文件过滤，均以堆栈块的ID为标志进行比对。过滤掉相同ID的堆栈块。将其他信息上传至tos并把文件url返回给用户。

##收获
- 技术：
  1、读写锁
  2、正则匹配
  3、http请求
  4、简单的错误分类与处理
- 非技术：
  这是实习之后的第一个项目，可以看得出来不是很难，只是一个练手的项目，十天左右的时间就完成了第一稿。我的需求方，其实也并不是很重视这个项目，他们对于自己的需求（具体指对比规则），并没有梳理清楚。
  为了避免出现需求大改的情况，我对QA的需求场景（QA质量保障工程师，我的需求方）进行了饱和式的了解。具体包括但不限于：为什么会有这两种对比模式，堆栈文件中各种信息代表的具体含义是什么，为什么会产生这些堆栈信息
  是在测试哪些场景，等等。
  了解了这些需求场景后，在QA提需求的时候，我可以更加清晰地理解这个需求产生的原因，以及这个需求以后可能会如何变化，并与QA进行确认。甚至还提出了一些QA自己可能没有考虑周全的一些需求，比如：
  1、原需求：libeffect.so文件下产生的堆栈信息都当作无效信息直接过滤掉。而我认为除了这个.so文件之外，以后是不是还会有其他的.so文件下的信息是无效信息，在与QA确认确实有这种可能后，我在code时建立了一个soMap，用以区分各种so文件。
  2、原需求：需要有一个添加黑名单的工作，把黑名单一条一条地放进去。当时考虑到可能服务最初上线时，会有比较大量的黑名单信息需要添加，我和QA确认是否需要一个批量上传的功能，将黑名单文件传进来，可以直接识别所有堆栈信息并逐个添加上传。

##简历表述：
针对测试工程师目前人工查看日志检查单元测试产生的内存泄漏效率低、准确率低的情况，利用gin框架搭建stackdiff服务，提供堆栈信息对比服务以及黑名单服务；利用正则匹配提取日志文件中有效信息，使用MD5加密算法生成ID，
根据ID对日志文件中的无效信息以及旧信息进行过滤，缩短单元测试时间20%。
在堆栈信息对比服务中，利用正则匹配提取日志文件中有效信息，分别通过md5加密生成ID，根据ID对日志文件中的无效信息以及旧信息进行过滤并上传至tos文件服务器中，并将过滤后文件的url返还给用户。
在黑名单服务中，维护黑名单原始信息文件以及存有黑名单中各条目md5值的黑名单ID文件。允许用户使用form-data格式上传黑名单文件，同时服务器对其进行解析并更新黑名单ID文件。
利用gin框架搭建服务，提供堆栈对比服务以及黑名单维护服务。在堆栈对比服务中，根据用户提供的task_id对task信息进行http