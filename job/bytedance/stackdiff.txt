##目标：
- 提供堆栈对比功能，实现今日产生的堆栈文件与昨日新出现的堆栈信息的自动对比，直观显示今日新出现的bug的堆栈信息；
- 提供黑名单增删操作，过滤堆栈文件中的无效信息。

##解决问题：
用堆栈的自动对比替代人工对比，实现堆栈对比自动化，减轻测试方压力，提高堆栈对比准确率。

##解决方案：
- 利用gin框架搭建服务器，对比功能上，提供两种对比模式：personalRun&dailyRun；黑名单维护功能上，提供add,delete,list三个接口
  personalRun:指个人行为的对比，只使用黑名单过滤方法，将堆栈信息中存在的黑名单信息进行过滤。
  dailyRun:指测试方设置的定时对比行为，每天一次，先使用黑名单进行过滤，再与前一天的堆栈文件进行对比，过滤掉前一天出现过的堆栈信息。
- 根据task_id获取task具体信息，其中包括堆栈信息的url。再进行GET请求，使用正则匹配的方式获取到存有堆栈信息的堆栈文件。再根据正则匹配提取出堆栈信息并存储在map中。
- 进而根据用户所选择的对比模式进行对比，其中黑名单在服务启动时自动从tos服务中获取，并常驻于服务中。对于黑名单的维护，使用到读写锁，可以同读，但不能同时读写。每次写入之后都会重新上传至tos服务中。

##收获
- 技术：
  1、读写锁
  2、正则匹配
  3、http请求
  4、简单的错误分类与处理
- 非技术：
  这是实习之后的第一个项目，可以看得出来不是很难，只是一个练手的项目，十天左右的时间就完成了第一稿。我的需求方，其实也并不是很重视这个项目，他们对于自己的需求（具体指对比规则），并没有梳理清楚。
  为了避免出现需求大改的情况，我对QA的需求场景（QA质量保障工程师，我的需求方）进行了饱和式的了解。具体包括但不限于：为什么会有这两种对比模式，堆栈文件中各种信息代表的具体含义是什么，为什么会产生这些堆栈信息
  是在测试哪些场景，等等。
  了解了这些需求场景后，在QA提需求的时候，我可以更加清晰地理解这个需求产生的原因，以及这个需求以后可能会如何变化，并与QA进行确认。甚至还提出了一些QA自己可能没有考虑周全的一些需求，比如：
  1、原需求：libeffect.so文件下产生的堆栈信息都当作无效信息直接过滤掉。而我认为除了这个.so文件之外，以后是不是还会有其他的.so文件下的信息是无效信息，在与QA确认确实有这种可能后，我在code时建立了一个soMap，用以区分各种so文件。
  2、原需求：需要有一个添加黑名单的工作，把黑名单一条一条地放进去。当时考虑到可能服务最初上线时，会有比较大量的黑名单信息需要添加，我和QA确认是否需要一个批量上传的功能，将黑名单文件传进来，可以直接识别所有堆栈信息并逐个添加上传。
