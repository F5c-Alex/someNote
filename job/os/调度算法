+ 调度算法
  - 先来先服务（FCFS）
  - 短作业优先（SJF）
  - 高响应比优先（HRRN）

+ 先来先服务（First Come First Serve）
  - 算法思想：主要从公平的角度考虑
  - 算法规则：按照作业/进程到达的先后顺序进行服务
  - 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列，用于进程调度时，考虑的是哪个进程先到达就绪队列
  - 是否可抢占：非抢占式算法
  - 优缺点：
    - 优点： 公平、实现简单
    - 缺点：排在长作业（进程）后面的短作业需要等待很长时间，待却周转时间很大，对短作业来说用户体验不好
  -是否会饥饿：不会

+ 短作业优先（Shortest Job First)
  - 算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间
  - 算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务的时间最短）；每次调度时选择当前已经到达且运行时间最短的作业/进程。
  - 用于作业/进程调度：既可用于作业调度，也可以用于进程调度。用于进程调度时称为“短进程优先（SPF,Shortest Process First)算法
  - 是否可抢占：SJF和SPF是非抢占式的算法，但是也有抢占式的版本--最短剩余时间优先算法（SRTN,Shortest Remaining Time Next）
    - 最短剩余时间优先算法：每当有进程加入就绪队列时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，
      则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。
  - 优缺点：
    - 优点：“最短的”平均等待时间、平均周转时间
    - 缺点： 不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业、进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。
  - 是否会饥饿：会，如果源源不断地有短作业、进程到来，可能使长作业、进程得长时间得不到服务，产生饥饿现象。如果一直得不到服务，则称为饿死。

FCFS只考虑等待时间，SJF只考虑运行时间，HRRN综合考虑这两点。

+ 高响应比优先（HRRN）
  - 算法思想：要综合考虑作业、进程的等待时间和要求服务时间
  - 算法规则：在每次调度时先计算各个作业、进程的响应比，选择响应比最高的作业、进程为其服务。
    响应比 = （等待时间+要求服务时间）/要求服务时间
  - 用于作业、进程调度：既可用于作业调度，也可以用于进程调度。
  - 是否可抢占：非抢占式的算法。因此只有当前运行的作业、进程主动放弃处理机时，才需要调度，才需要计算响应比。
  - 优缺点：综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF）；要求服务时间相同时，等待时间长的优先。
  对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。




+ 时间片轮转调度算法（RR)
  - 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
  - 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
  - 用于作业、进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
  - 是否可抢占： 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由始终装置发出的始终中断来通知CPU时间已到。
  - 优缺点：
    - 优点：公平，响应快，适用于分时操作系统。
    - 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。
  - 是否会导致饥饿：不会
  - 补充 ：如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大。
  另一方面，进程调度、切换是有时间代价的（保存，恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少，所以时间片也不能太小。
  
+ 优先级调度算法
  - 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
  - 算法规则：每个作业、进程都有各自的优先级，调度时选择优先级最高的作业、进程
  - 用于作业、进程调度：既可以用于作业调度、也可以用于进程调度。甚至还可以用于I/O调度。
  - 是否可抢占：抢占式、非抢占式都有；非抢占式只需在进程主动放弃处理机时进行调度即可，而非抢占式还需在就绪队列变化时，检查是否会发生抢占。
  - 补充：就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级。
  静态优先级：创建进程时确定，之后一直不变。
  动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级

  如何合理设置优先级：
  一般来说，系统进程优先级高于用户进程。前台进程优先级高于后台进程。操作系统更偏好I/O型进程（或称为I/O繁忙型进程）（与I/O型相对的是计算型进程，或称CPU繁忙型进程）
  偏好I/O的原因是I/O设备和CPU可以并行工作，如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早的投入工作，则资源利用率、系统吞吐量都可以得到提升。
  
  如果采用的是动态优先级，什么时候应该调整？
  可以从追求公平、提升资源利用率等角度考虑。
  如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级；
  如果是某进程占用处理机运行了很长时间，则可以适当降低其优先级；
  如果发现一个进程频繁地进行I/O操作，则可以适当提升其优先级。

  - 优缺点：
    - 优点：用优先级区分紧急程度，重要程度，适用于实施操作系统，可灵活地调整对各种作业、进程的偏好程度
    - 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
  
+ 多级反馈
  - 算法思想：对其他调度算发的折中权衡
  - 算法规则：
    1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    2.新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
    3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片
  - 用于作业/进程调度：用于进程调度
  - 是否可抢占：抢占式的算法，在k级队列的进程运行过程中，若更上级的队列（1～k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾
  - 优缺点：对各类型进程相对公平（FCFS）；每个新到达的进程都可以很快就得到相应（RR）的优点；短进程只用较少的时间就可以完成（SPF）；不必实现估计进程的运行时间（避免用户作假）；
  可以灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
  - 会导致饥饿